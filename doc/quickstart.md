# Quickstart

This guide is intended to provide quick instructions on how to run the analysis.

## Set the root folder

The files architecture is mainly described [in the focus](https://github.com/LaboJeanPerrin/NeuroTools/blob/master/Matlab/%2BNT/%40Focus/architecture.m). To start an analysis, you have to provide the root path with the following folders.

    Root
    ├── Data
    │   ├── 2018-01-11
    │   │   ├── Run 01
    │   │   ├── Run 02
    │   ├── ...
    │   └── 2018-03-19
    │       └── Run 02
    └── Programs
        ├── easyRLS
        └── NeuroTools

To prevent you from installing the code several times for several projects, you can create a symbolic link to the standard location of programs.

	ln -s /home/ljp/Programs
Or in windows

	mklink -D Programs C:\\Science\Programs

## Prepare the data

An empty run folder should look like this.

    Run 03
    ├── Images
    │   ├── rec00001.dcimg
    │   └── rec00001.mat
    ├── Parameters.txt
    └── Stimulus.txt

With the 'Parameters.txt' generated by the Lightsheet program. The mat file aside the dcimg contains informations about the dcimg. Alternatively, you can put a tif image extracted from this dcimg and the program will automatically extract metadata from it.

As a preview, after running the analysis, you will have something like this.

    Run 03
    ├── Analysis
    │   ├── Background
    │   ├── Baseline
    │   ├── corrected.stack
    │   ├── DFF
    │   ├── Drift
    │   ├── graystack.stack
    │   ├── Mask
    │   ├── PhaseMap
    │   └── Segmentation
    ├── Config.mat
    ├── Images
    │   ├── dcimg.dcimg
    │   └── dcimg.mat
    ├── Parameters.txt
    └── Stimulus.txt

## Edit a template and create the focus

The file 'TEMPLATE.mat' gives you a template to configure the focus. *Do not edit it*, instead, copy it and modify it locally with a personalised name (ex Template_Hugo.m).

Once you have your own template, run the function 'addPrograms' which adds the programs to the Matlab path and loads the dependencies ('caTools' library has to be installed).

	addPrograms('/home/ljp/Programs');

Then you can change the following parameters according to your needs

    root = '/home/ljp/Science/Projects/RLS/';
    study = '';
    date = '0000-00-00';
    run = 0;

and create the focus with

    F = NT.Focus(root, study, date, run);

The focus is your golden thread for data analysis, it knows the data architecture. It's the first argument of most of the functions.

To do the analysis, you need to load certain parameters in the focus

    Analysis.Layers = 3:20;         % Layers to analyse
    Analysis.RefLayers = 6:6;       % reference layers for drift correction
    Analysis.RefIndex = 10;         % index of the reference frame for drift correction
    Analysis.RefStack = '';         % external reference stack if exists

    Analysis.BaselineWindow = 50;           % time in seconds of the baseline window
    Analysis.DriftBox = [ 53 566 45 914 ];  % bounding box for drift correction
    Analysis.Lineage = 'Cytoplasmic';       % possible values : 'Nuclear', 'Cytoplasmic'
    Analysis.StimulusFrequency = 0.2;       % frequency of stimulus (Hz) for phasemap computation

    F.Analysis = Analysis;

After this you can run step by step the 'main.m' file to understand how the analysis works and view the output step by step or you can run a workflow by looking the following.

### Main script
The main script gives you a list of all the functions and all the viewers. It helps you understand how the program works.

#### 'Focused' function
Certain functions can be used manually (without focus). Aliases for these functions are groupped in the +Focused package, allowing to call them with the advantages of the focus.

#### stackViewer
The 'stackViewer' function lets you see a 4D matrix (x,y,z,t) as a 2D image with sliders for z and t. A trick hidden in the 'Focused' version of stackViewer allows you to see a binary file as well as a DCIMG or a collection of TIF images by just identifying it by its tag.

#### semiAutoROI
This function tries to draw the ROI and lets you adjust it. It creates a "mask" 3D matrix in the 'Mask' folder. TODO improve this function.

#### driftCompute
This function computes the x and y drifts (dx, dy) for all stack compared to a reference frame. The reference image is computed as the max projection of the given layers. The drift is computed on a given region by auto-correlation (in Fourier domain). The computed drift can be previewed with seeDriftCorrection before applying it with driftApply.

#### computeBackground
The DFF computation requires the background to be computed first. It sets the level of dark by a custom fitting method.

#### createGrayStack
The graystack is a t-averaged stack after drift correction. In our case, the drift is corrected with undersampling.

#### segmentBrain
The data are segmented for a per-neuron analysis, faster than the per-pixel analysis. The algorithm used is of the watershed kind. The following functions take an argument which can be either 'neuron' or 'pixel'.

The segmentBrain function also concatenates all the coordinates and convert them in µm in the 'coordinates.m' file.

#### computeBaseline
The baseline is computed as the 10th percentile of the data on a moving window (the percentile can be changed in the parameters, see 'template'). The algorithm used is implemented in the 'caTools' R library ([runquantile](https://www.rdocumentation.org/packages/caTools/versions/1.17.1/topics/runquantile) funtion) and loaded in matlab with 'loadlibrary'. It is only computed on the ROI given in the mask. It produces a collection of 3D stacks (one per layer) and stored before computing the DFF. It requires a special viewer poorly named stackViewer2D.

#### computeDFF
The dff (delta f over f), the relative intensity of the signal, is computed with the following formula.

![\frac{\Delta f}{f} = \frac{\text{Signal} - \text{Baseline}}{\text{Baseline} - \text{Background}}](img/dff.svg)

It is stored as single precision values and can also be viewed with stackViewer2D.

#### computePhaseMap
The phasemap mesures the spectral response at the stimulus frequency. The phaseMapViewer allows to view the complex numbers in hsv space.

TODO detail descrete Fourier transform

#### mapToRefBrain
mapRoRefBrain is a wrapper function for cmtk tools. You can first run 'chooseRefBrain' to select the reference brain you want to work with. It will search a nhdr file with absolute path link and copy it in your analysis folder. It allows:

- to avoid copying one reference brain per analysis
- to keep track of the reference brain you're working with
- to force reference brain organisation
- to have a sinle text file describing the reference brain

You can also manually copy it.

mapToRefBrain currently contains four subfunctions listed below.

- affine (computes an affine registration)
- warp (computes a non-rigid transformation)
- reformat (applies one of the computed transformation)
- convertcood (applies the transformation on the coordinates)

Once you converted the coordinates in the reference brain, you can run exportToHDF5.

#### exportToHDF5
This function exports the data in a HDF5 file compatible with fishualizer program.

### Workflow
See 'sample analysis' and 'sample workflow' in the template to have a model to run the workflow.